/******************************************************************************/
/***          Generated by IBExpert 2012.03.13 12.05.2012 12:12:12          ***/
/******************************************************************************/

SET NAMES WIN1251;

CREATE DATABASE 'server:b52'
USER 'SYSDBA'
PAGE_SIZE 8192
DEFAULT CHARACTER SET WIN1251;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR BFW_INF_MSG_GEN;


/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION BFW_RAISE 'ERROR';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_ITEM (
    URI_ VARCHAR(50))
RETURNS (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    MENUIDX INTEGER,
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024),
    USEPERM INTEGER,
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50),
    ENT_EVIEW VARCHAR(100),
    ENT_VIEW_READONLY INTEGER,
    ENT_VIEW_PKEY VARCHAR(50),
    ENT_SQL_SELECT VARCHAR(1024),
    ENT_SQL_INSERT VARCHAR(1024),
    ENT_SQL_INSERTDEF VARCHAR(1024),
    ENT_SQL_UPDATE VARCHAR(1024),
    ENT_SQL_DELETE VARCHAR(1024),
    ENT_SQL_REFRESH VARCHAR(1024),
    UI_TITLE VARCHAR(250))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_ITEM_U (
    URI VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    MENUIDX INTEGER,
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024),
    USEPERM INTEGER,
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50),
    ENT_VIEW_READONLY INTEGER,
    ENT_VIEW_PKEY VARCHAR(50),
    ENT_SQL_SELECT VARCHAR(1024),
    ENT_SQL_INSERT VARCHAR(1024),
    ENT_SQL_INSERTDEF VARCHAR(1024),
    ENT_SQL_UPDATE VARCHAR(1024),
    ENT_SQL_DELETE VARCHAR(1024),
    ENT_SQL_REFRESH VARCHAR(1024))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_NEW
RETURNS (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    TITLE VARCHAR(50),
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50),
    ENT_EVIEW VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_NEW_U (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    TITLE VARCHAR(50),
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_CHECK (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    COMMON_EXISTS INTEGER,
    USER_EXISTS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_GET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_SET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50),
    VALI_ INTEGER,
    VALS_ VARCHAR(250),
    VALN_ DOUBLE PRECISION,
    VALD_ DATE)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_POP (
    FROM_ID_ INTEGER)
RETURNS (
    ID INTEGER,
    SDAT DATE,
    SENDER VARCHAR(38),
    TOPIC VARCHAR(50),
    TXT VARCHAR(250))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_PUSH (
    RECEIVER_ VARCHAR(38),
    TOPIC_ VARCHAR(50),
    TXT_ VARCHAR(250))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING_ (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_PERM VARCHAR(50),
    INHERITBY_RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_LEN (
    STRG_IN VARCHAR(1024))
RETURNS (
    STRG_LEN INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_REPLACE (
    STR_IN VARCHAR(1024),
    STR_SEARCH VARCHAR(1024),
    STR_REPLACE VARCHAR(1024))
RETURNS (
    STR_OUT VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_SUB (
    STR_IN VARCHAR(1024),
    STR_BEG INTEGER,
    STR_LEN INTEGER)
RETURNS (
    STR_OUT VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE BFW_ENT (
    ENTITYNAME   VARCHAR(38) NOT NULL,
    SCHEMENAME   VARCHAR(38),
    IS_SCHEME    INTEGER DEFAULT 0 NOT NULL,
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE BFW_ENT_FIELDS (
    ENTITYNAME      VARCHAR(38) NOT NULL,
    VIEWNAME        VARCHAR(38) NOT NULL,
    FIELDNAME       VARCHAR(38) NOT NULL,
    BAND            VARCHAR(50),
    TITLE           VARCHAR(50),
    VISIBLE         INTEGER DEFAULT 1 NOT NULL,
    READONLY        INTEGER DEFAULT 0 NOT NULL,
    EDITOR          VARCHAR(50),
    EDITOR_OPTIONS  VARCHAR(1024),
    OPTIONS         VARCHAR(1024),
    REQ             INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE BFW_ENT_VIEW_LINKS (
    ENTITYNAME         VARCHAR(38) NOT NULL,
    VIEWNAME           VARCHAR(38) NOT NULL,
    LINKED_ENTITYNAME  VARCHAR(38) NOT NULL,
    LINKED_VIEWNAME    VARCHAR(38) NOT NULL,
    LINKED_FIELD       VARCHAR(38)
);


CREATE TABLE BFW_ENT_VIEWS (
    ENTITYNAME     VARCHAR(38) NOT NULL,
    VIEWNAME       VARCHAR(38) NOT NULL,
    SQL_SELECT     VARCHAR(1024),
    SQL_INSERT     VARCHAR(1024),
    SQL_UPDATE     VARCHAR(1024),
    SQL_DELETE     VARCHAR(1024),
    SQL_REFRESH    VARCHAR(1024),
    READONLY       INTEGER DEFAULT 1 NOT NULL,
    PKEY           VARCHAR(38),
    OPTIONS        VARCHAR(1024),
    IS_EXEC        INTEGER DEFAULT 0 NOT NULL,
    SQL_INSERTDEF  VARCHAR(1024)
);


CREATE TABLE BFW_INF_MSG (
    ID        INTEGER NOT NULL,
    STATUS    INTEGER DEFAULT 0 NOT NULL,
    SENDER    VARCHAR(38) DEFAULT USER NOT NULL,
    RECEIVER  VARCHAR(38) NOT NULL,
    TOPIC     VARCHAR(50) NOT NULL,
    TXT       VARCHAR(250) NOT NULL,
    IDAT      DATE DEFAULT 'NOW' NOT NULL,
    RDAT      DATE
);


CREATE TABLE BFW_INF_SETTINGS (
    NAME  VARCHAR(50) NOT NULL,
    USR   VARCHAR(50) NOT NULL,
    VALI  INTEGER,
    VALS  VARCHAR(250),
    VALN  DOUBLE PRECISION,
    VALD  DATE
);


CREATE TABLE BFW_INF_SETTINGS_META (
    NAME            VARCHAR(50) NOT NULL,
    TYP             INTEGER NOT NULL,
    TITLE           VARCHAR(50) NOT NULL,
    BAND            VARCHAR(50),
    IS_PREFERENCE   INTEGER DEFAULT 0 NOT NULL,
    EDITOR          VARCHAR(50),
    EDITOR_OPTIONS  VARCHAR(250),
    B52_NAME        VARCHAR(50),
    DEF_VALI        INTEGER,
    DEF_VALS        VARCHAR(250),
    DEF_VALN        DOUBLE PRECISION,
    DEF_VALD        DATE
);


CREATE TABLE BFW_SEC_ACL (
    PERMID  VARCHAR(38) NOT NULL,
    USERID  VARCHAR(38) NOT NULL,
    RESID   VARCHAR(38) NOT NULL,
    STATE   INTEGER NOT NULL
);


CREATE TABLE BFW_SEC_PERMISSIONS (
    PERMID       VARCHAR(38) NOT NULL,
    NAME         VARCHAR(50) NOT NULL,
    POLID        VARCHAR(38) NOT NULL,
    INHERITBY    VARCHAR(38),
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE BFW_SEC_POLICIES (
    POLID           VARCHAR(38) NOT NULL,
    NAME            VARCHAR(50) NOT NULL,
    PARENTID        VARCHAR(38),
    STATE           INTEGER NOT NULL,
    USE_RES         INTEGER NOT NULL,
    RES_PROVID      VARCHAR(38),
    RES_PARENT_SQL  VARCHAR(1024)
);


CREATE TABLE BFW_SEC_PROV (
    URI         VARCHAR(50) NOT NULL,
    ENTITYNAME  VARCHAR(50) NOT NULL
);


CREATE TABLE BFW_SEC_USER_ROLES (
    USERID  VARCHAR(38) NOT NULL,
    ROLEID  VARCHAR(38) NOT NULL
);


CREATE TABLE BFW_SEC_USERS (
    USERID  VARCHAR(38) NOT NULL,
    NAME    VARCHAR(50) NOT NULL,
    ISROLE  INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE BFW_UI (
    URI         VARCHAR(50) NOT NULL,
    CLS         VARCHAR(50) NOT NULL,
    ENTITYNAME  VARCHAR(50) NOT NULL,
    VIEWNAME    VARCHAR(50),
    TITLE       VARCHAR(50) NOT NULL,
    GRP         VARCHAR(50),
    MENUIDX     INTEGER DEFAULT 0 NOT NULL,
    OPTIONS     VARCHAR(1024),
    PARAMS      VARCHAR(1024),
    OUTS        VARCHAR(1024),
    USEPERM     INTEGER DEFAULT 0 NOT NULL,
    PKG         VARCHAR(50)
);


CREATE TABLE BFW_UI_CLS (
    CLS          VARCHAR(50) NOT NULL,
    VIEWNAME     VARCHAR(50) NOT NULL,
    DESCRIPTION  VARCHAR(250),
    IMG          BLOB SUB_TYPE 0 SEGMENT SIZE 8192,
    OPTIONS      VARCHAR(1024)
);


CREATE TABLE BFW_UI_CMD (
    URI               VARCHAR(50) NOT NULL,
    CMD               VARCHAR(50) NOT NULL,
    CAPTION           VARCHAR(50) NOT NULL,
    IDX               INTEGER DEFAULT 0 NOT NULL,
    GRP               VARCHAR(50),
    DEF               INTEGER DEFAULT 0 NOT NULL,
    HANDLER           VARCHAR(50),
    PARAMS            VARCHAR(1024),
    OUTS              VARCHAR(1024),
    OPTIONS           VARCHAR(1024),
    CONDITION         VARCHAR(50),
    CONDITION_PARAMS  VARCHAR(50)
);


CREATE TABLE BFW_UI_GRP (
    GRP  VARCHAR(50) NOT NULL,
    IDX  INTEGER
);


CREATE TABLE BFW_UI_STYLES (
    ID       VARCHAR(50) NOT NULL,
    OPTIONS  VARCHAR(1024)
);




/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE BFW_ENT_VIEW_LINKS ADD CONSTRAINT UNQ1_BFW_ENT_VIEW_LINKS UNIQUE (ENTITYNAME, VIEWNAME, LINKED_ENTITYNAME, LINKED_VIEWNAME, LINKED_FIELD);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE BFW_ENT ADD CONSTRAINT PK_BFW_ENT PRIMARY KEY (ENTITYNAME);
ALTER TABLE BFW_ENT_FIELDS ADD CONSTRAINT PK_BFW_ENT_FIELDS PRIMARY KEY (ENTITYNAME, VIEWNAME, FIELDNAME);
ALTER TABLE BFW_ENT_VIEWS ADD CONSTRAINT PK_BFW_ENT_VIEWS PRIMARY KEY (ENTITYNAME, VIEWNAME);
ALTER TABLE BFW_INF_MSG ADD CONSTRAINT PK_BFW_INF_MSG PRIMARY KEY (ID);
ALTER TABLE BFW_INF_SETTINGS ADD CONSTRAINT PK_BFW_INF_SETTINGS PRIMARY KEY (NAME, USR);
ALTER TABLE BFW_INF_SETTINGS_META ADD CONSTRAINT PK_BFW_INF_SETTINGS_META PRIMARY KEY (NAME);
ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT PK_BFW_SEC_ACL PRIMARY KEY (PERMID, USERID, RESID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT PK_BFW_SEC_PERMISSIONS PRIMARY KEY (PERMID);
ALTER TABLE BFW_SEC_POLICIES ADD CONSTRAINT PK_BFW_SEC_POLICIES PRIMARY KEY (POLID);
ALTER TABLE BFW_SEC_PROV ADD CONSTRAINT PK_BFW_SEC_PROV PRIMARY KEY (URI);
ALTER TABLE BFW_SEC_USERS ADD CONSTRAINT PK_BFW_SEC_USERS PRIMARY KEY (USERID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT PK_BFW_SEC_USER_ROLES PRIMARY KEY (USERID, ROLEID);
ALTER TABLE BFW_UI ADD CONSTRAINT PK_BFW_UI PRIMARY KEY (URI);
ALTER TABLE BFW_UI_CLS ADD CONSTRAINT PK_BFW_UI_CLS PRIMARY KEY (CLS);
ALTER TABLE BFW_UI_CMD ADD CONSTRAINT PK_BFW_UI_CMD PRIMARY KEY (URI, CMD);
ALTER TABLE BFW_UI_GRP ADD CONSTRAINT PK_BFW_UI_GRP PRIMARY KEY (GRP);
ALTER TABLE BFW_UI_STYLES ADD CONSTRAINT PK_BFW_UI_STYLES PRIMARY KEY (ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT FK_BFW_SEC_ACL_PERM FOREIGN KEY (PERMID) REFERENCES BFW_SEC_PERMISSIONS (PERMID);
ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT FK_BFW_SEC_ACL_USERID FOREIGN KEY (USERID) REFERENCES BFW_SEC_USERS (USERID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT FK_BFW_SEC_PERMISSIONS_INHERITB FOREIGN KEY (INHERITBY) REFERENCES BFW_SEC_PERMISSIONS (PERMID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT FK_BFW_SEC_PERMISSIONS_POLID FOREIGN KEY (POLID) REFERENCES BFW_SEC_POLICIES (POLID);
ALTER TABLE BFW_SEC_POLICIES ADD CONSTRAINT FK_BFW_SEC_POLICIES_PARENT FOREIGN KEY (PARENTID) REFERENCES BFW_SEC_POLICIES (POLID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT FK_BFW_SEC_USER_ROLES_ROLEID FOREIGN KEY (ROLEID) REFERENCES BFW_SEC_USERS (USERID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT FK_BFW_SEC_USER_ROLES_USERID FOREIGN KEY (USERID) REFERENCES BFW_SEC_USERS (USERID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: BFW_INF_MSG_BU */
CREATE OR ALTER TRIGGER BFW_INF_MSG_BU FOR BFW_INF_MSG
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.status <> old.status and old.status = 0) then
    new.rdat = 'NOW';
end
^


/* Trigger: BFW_SEC_PERMISSIONS_BD */
CREATE OR ALTER TRIGGER BFW_SEC_PERMISSIONS_BD FOR BFW_SEC_PERMISSIONS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from bfw_sec_acl a where a.permid = old.permid;
end
^


/* Trigger: BFW_SEC_POLICIES_BD */
CREATE OR ALTER TRIGGER BFW_SEC_POLICIES_BD FOR BFW_SEC_POLICIES
ACTIVE BEFORE DELETE POSITION 0
as
begin
  if (old.polid = 'BUILD-IN') then
    exception bfw_raise 'It is not allowed for built-in policy';
end
^


/* Trigger: BFW_SEC_POLICIES_BU */
CREATE OR ALTER TRIGGER BFW_SEC_POLICIES_BU FOR BFW_SEC_POLICIES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.polid = 'BUILT-IN' and new.state <> old.state and new.state = 0) then
    exception bfw_raise 'It is not allowed for built-in policy';
end
^


/* Trigger: BFW_SEC_USERS_BD */
CREATE OR ALTER TRIGGER BFW_SEC_USERS_BD FOR BFW_SEC_USERS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from bfw_sec_acl a where a.userid = old.userid;
  delete from bfw_sec_user_roles r where r.userid = old.userid;
  delete from bfw_sec_user_roles r where r.roleid = old.userid;
end
^


/* Trigger: BFW_SEC_USERS_BI */
CREATE OR ALTER TRIGGER BFW_SEC_USERS_BI FOR BFW_SEC_USERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.name is null) then
    new.name = new.userid;
end
^


/* Trigger: BFW_SEC_USERS_BU */
CREATE OR ALTER TRIGGER BFW_SEC_USERS_BU FOR BFW_SEC_USERS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.name is null) then
    new.name = new.userid;
end
^


SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_ITEM (
    URI_ VARCHAR(50))
RETURNS (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    MENUIDX INTEGER,
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024),
    USEPERM INTEGER,
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50),
    ENT_EVIEW VARCHAR(100),
    ENT_VIEW_READONLY INTEGER,
    ENT_VIEW_PKEY VARCHAR(50),
    ENT_SQL_SELECT VARCHAR(1024),
    ENT_SQL_INSERT VARCHAR(1024),
    ENT_SQL_INSERTDEF VARCHAR(1024),
    ENT_SQL_UPDATE VARCHAR(1024),
    ENT_SQL_DELETE VARCHAR(1024),
    ENT_SQL_REFRESH VARCHAR(1024),
    UI_TITLE VARCHAR(250))
AS
begin
  select ui.uri, ui.cls, ui.title, ui.grp, ui.menuidx, ui.options,
         ui.params, ui.outs, ui.useperm, ui.pkg,
         ui.entityname, coalesce(ui.viewname, cls.viewname),
         ev.sql_select, ev.sql_insert, ev.sql_update, ev.sql_delete,
         ev.sql_refresh, ev.sql_insertdef,
         ev.readonly, ev.pkey
  from bfw_ui ui
       left join bfw_ui_cls cls on (cls.cls = ui.cls)
       left join bfw_ent_views ev on (ev.entityname = ui.entityname and ev.viewname = coalesce(ui.viewname, cls.viewname))
  where ui.uri = :uri_
  into :uri, :cls, :title, :grp, :menuidx, :options,
       :params, :outs, :useperm, :pkg,
       :ent, :ent_view,
       :ent_sql_select, :ent_sql_insert, :ent_sql_update, :ent_sql_delete,
       :ent_sql_refresh, :ent_sql_insertdef,
       :ent_view_readonly, :ent_view_pkey;

  ENT_EVIEW = ent || '.' || coalesce(:ent_view, '');

  UI_TITLE = 'UI: ' || title;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_ITEM_U (
    URI VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    MENUIDX INTEGER,
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024),
    USEPERM INTEGER,
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50),
    ENT_VIEW_READONLY INTEGER,
    ENT_VIEW_PKEY VARCHAR(50),
    ENT_SQL_SELECT VARCHAR(1024),
    ENT_SQL_INSERT VARCHAR(1024),
    ENT_SQL_INSERTDEF VARCHAR(1024),
    ENT_SQL_UPDATE VARCHAR(1024),
    ENT_SQL_DELETE VARCHAR(1024),
    ENT_SQL_REFRESH VARCHAR(1024))
AS
begin
  update bfw_ui
  set title = :title,
      grp = :grp,
      menuidx = :menuidx,
      options = :options,
      params = :params,
      outs = :outs,
      useperm = :useperm,
      pkg = :pkg
  where uri = :uri;


  update bfw_ent_views ev
  set ev.sql_select = :ent_sql_select,
      ev.sql_insert = :ent_sql_insert,
      ev.sql_insertdef = :ent_sql_insertdef,
      ev.sql_update = :ent_sql_update,
      ev.sql_delete = :ent_sql_delete,
      ev.sql_refresh = :ent_sql_refresh,
      ev.pkey = :ent_view_pkey,
      ev.readonly = :ent_view_readonly
  where ev.entityname = :ent and ev.viewname = :ent_view;
end^


CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_NEW
RETURNS (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    TITLE VARCHAR(50),
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50),
    ENT_EVIEW VARCHAR(100))
AS
begin

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_IDE_EV_UI_NEW_U (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    TITLE VARCHAR(50),
    PKG VARCHAR(50),
    ENT VARCHAR(50),
    ENT_VIEW VARCHAR(50))
AS
begin
  ent = upper(ent);

  insert into bfw_ui(uri, cls, title, pkg, entityname, viewname)
  values(:uri, :cls, :title, :pkg, :ent, :ent_view);

  if (not exists(select * from bfw_ent_views where entityname = :ent and viewname = :ent_view)) then
  begin
    insert into bfw_ent_views(entityname, viewname)
    values(:ent, :ent_view);
  end
end^


CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_CHECK (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    COMMON_EXISTS INTEGER,
    USER_EXISTS INTEGER)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));

  common_exists = 0; user_exists = 0;

  if (exists(select * from  bfw_inf_settings s
      where s.name = :name_ and s.usr = :username_)) then
    user_exists = 1;

  if (exists(select * from bfw_inf_settings s
      where s.name = :name_ and s.usr = '')) then
    common_exists = 1;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_GET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));
  select s.vali, s.vals, s.valn, s.vald
  from bfw_inf_settings s
  where s.name = :name_ and s.usr = :username_
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null and username_ <> '') then
    select s.vali, s.vals, s.valn, s.vald
    from bfw_inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from bfw_inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_SET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50),
    VALI_ INTEGER,
    VALS_ VARCHAR(250),
    VALN_ DOUBLE PRECISION,
    VALD_ DATE)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));

  if (vali_ is null and vals_ is null and valn_ is null and vald_ is null) then
    delete from bfw_inf_settings s
    where s.name = :name_ and s.usr = :username_;
  else
  begin
    if (exists(select * from bfw_inf_settings s where s.name = :name_ and usr = :username_)) then
      update bfw_inf_settings s
      set s.vali = :vali_, s.vals = :vals_, s.valn = :valn_, s.vald = :vald_
      where s.name = :name_ and s.usr = :username_;
    else
      insert into bfw_inf_settings(name, usr, vali, vals, valn, vald)
      values(:name_, :username_, :vali_, :vals_, :valn_, :vald_);
  end
end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_POP (
    FROM_ID_ INTEGER)
RETURNS (
    ID INTEGER,
    SDAT DATE,
    SENDER VARCHAR(38),
    TOPIC VARCHAR(50),
    TXT VARCHAR(250))
AS
declare variable receiver varchar(38);
begin
  receiver = user;
  from_id_ = coalesce(from_id_, 0);

  for
    select m.id, m.idat, coalesce(u.name, m.sender),  m.topic, m.txt
    from bfw_inf_msg m
         left join bfw_sec_users u on (u.userid = m.sender)
    where m.receiver = :receiver and m.status = 0 and m.id > :from_id_
    order by m.id
    into :id, :sdat, :sender, :topic, :txt
  do
    suspend;

end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_PUSH (
    RECEIVER_ VARCHAR(38),
    TOPIC_ VARCHAR(50),
    TXT_ VARCHAR(250))
AS
declare variable id integer;
begin
  receiver_ = upper(receiver_);
  id = gen_id(bfw_inf_msg_gen, 1);
  insert into bfw_inf_msg(id, receiver, topic, txt)
  values(:id, :receiver_, :topic_, :txt_);

end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
declare variable setting_title varchar(50);
begin
  select vali, vals, valn, vald from bfw_inf_sp_setting_(:name_)
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
  begin
    select m.title from bfw_inf_settings_meta m where m.name = :name_
    into :setting_title;

    setting_title = coalesce(setting_title, name_);

    exception bfw_raise 'Value for ''' || :setting_title || ''' undefined';
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING_ (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);

  select s.vali, s.vals, s.valn, s.vald
  from  bfw_inf_settings s
  where s.name = :name_ and s.usr = USER
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.vali, s.vals, s.valn, s.vald
    from  bfw_inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from  bfw_inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_PERM VARCHAR(50),
    INHERITBY_RESID VARCHAR(38))
AS
declare variable permcheck varchar(38);
declare variable permid varchar(38);
declare variable resid varchar(38);
begin
  permid_ = nullif(permid_, '');
  for
    select userid, name
    from bfw_sec_users
    into :userid, :username
  do begin
    for
      select p.permid, p.name
      from bfw_sec_policies pl left join bfw_sec_permissions p  on (pl.polid = p.polid)
      where pl.polid = :polid_
            and ((:permid_ is null) or (:permid_ is not null and p.permid = :permid_))
      into :permcheck, :perm
    do begin
      state = null;
      inheritby_perm = null;
      inheritby_resid = null;
      permid = null;
      resid = null;
      select p.state, p.permid, p.resid
      from bfw_sec_ev_perm_effective_(:permcheck, :userid, :resid_) p
      into :state, :permid, :resid;
      if (state is not null) then
      begin
        if (permid <> permcheck) then
          select name from bfw_sec_permissions p
          where p.permid = :permid
          into :inheritby_perm;

        if (coalesce(resid, resid_) <> resid_) then
          inheritby_resid = resid;

        suspend;
      end
    end
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
declare variable inheritby varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');
  permid = permid_;
  resid = resid_;

  for
    select a.state
    from bfw_sec_acl a
    where a.resid = :resid_ and a.userid = :userid_ and a.permid = :permid_
    into :state
  do
    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end

  select p.inheritby, pol.res_parent_sql
  from bfw_sec_permissions p left join bfw_sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :inheritby, :res_parent_sql;

  if (inheritby is null and res_parent_sql is null) then
  begin
    exit;
  end

  parent_resid = '';
  if (coalesce(res_parent_sql, '') <> '') then
  begin
    res_parent_sql = upper(res_parent_sql);
    execute procedure bfw_utl_sp_string_replace(:res_parent_sql, ':RESID', :resid_)
    returning_values :res_parent_sql;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      inheritby = permid_;

  end

  if (inheritby is not null) then
  begin
    select state, permid, resid from bfw_sec_ev_perm_effective_(:inheritby, :userid_, :parent_resid)
    into :state, :permid, :resid;

    if (state in (1, 2)) then
      suspend;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(50))
AS
begin
  for
    select p.permid, p.name, p.description, pi.name
    from bfw_sec_permissions p
         left join bfw_sec_permissions pi on (p.inheritby = pi.permid)
    where p.polid = :polid
    into :permid, :name, :description, :inheritby
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');
  select state
  from bfw_sec_acl p
  where p.resid = :resid and p.userid = :userid and p.permid = :permid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');

  if (state = 0) then
    delete from bfw_sec_acl p
       where p.resid = :resid and p.userid = :userid and p.permid = :permid;
  else
  begin
    if (exists(select * from bfw_sec_acl p
              where p.resid = :resid
                    and p.userid = :userid and p.permid = :permid)) then
     update bfw_sec_acl p
     set p.state = :state
     where p.resid = :resid and p.userid = :userid and p.permid = :permid;
    else
      insert into bfw_sec_acl(resid, userid, permid, state)
      values (:resid, :userid, :permid, :state);
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
begin
  for
    select p.polid, p.name, p.res_provid
    from bfw_sec_policies p
    where p.parentid is null and coalesce(:parentid, '') = ''
    union all
    select p.polid, p.name, p.res_provid
    from bfw_sec_policies p
    where p.parentid = :parentid and coalesce(:parentid, '') <> ''
    into :polid, :name, :res_provid
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
begin
  delete from bfw_sec_acl a
  where a.permid in (select p.permid from bfw_sec_permissions p where p.polid = :polid_);
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  select state
  from bfw_sec_policies p where p.polid= :polid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
begin
  update bfw_sec_policies p
  set p.state = :state
  where p.polid = :polid;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable unrestricted_perm varchar(38) = 'builtin.unrestricted' ;
declare variable pol_state integer;
declare variable roleid varchar(38);
declare variable parent_permid varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');

  select a.state
  from bfw_sec_acl a
  where a.permid = :unrestricted_perm and a.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

  select first 1 a.state
  from bfw_sec_acl a
       left join bfw_sec_user_roles r on (a.userid = r.roleid)
  where a.permid = :unrestricted_perm and r.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

  select p.inheritby, pol.res_parent_sql, pol.state
  from bfw_sec_permissions p left join bfw_sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :parent_permid, :res_parent_sql, :pol_state;

  if (pol_state <> 1) then
  begin
    state = 1;
    suspend;
    exit;
  end

  for
    select a.state
    from bfw_sec_acl a
    where a.resid = :resid_ and a.userid = :userid_ and a.permid = :permid_
    into :state
  do
    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end

  for
    select r.roleid
    from bfw_sec_user_roles r
    where r.userid = :userid_
    into :roleid
  do begin
    select a.state
    from bfw_sec_acl a
    where a.resid = :resid_ and a.userid = :roleid and a.permid = :permid_
    into :state;

    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end
  end

  if (parent_permid is null and res_parent_sql is null) then
  begin
    state = 0;
    suspend;
    exit;
  end

  parent_resid = '';
  if (coalesce(res_parent_sql, '') <> '') then
  begin
    res_parent_sql = upper(res_parent_sql);
    execute procedure bfw_utl_sp_string_replace(:res_parent_sql, ':RESID', :resid_)
    returning_values :res_parent_sql;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      parent_permid = permid_;

  end

  if (parent_permid is not null) then
  begin
    select state from bfw_sec_sp_perm_check(:parent_permid, :userid_, :parent_resid)
    into :state;
    suspend;
    exit;
  end
  else
  begin
    state = 0;
    suspend;
    exit;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
declare variable userid  varchar(38);
declare variable pstate integer;
declare variable pname varchar(250);
begin
  userid = user;
  select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
  into :pstate;

  if (pstate <> 1) then
  begin
    select name from bfw_sec_permissions p where p.permid = :permid_
    into :pname;

    pname = coalesce(pname, permid_);

    pname = 'No permission for: ' || pname;
    exception bfw_raise :pname;

  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
declare variable state integer;
begin
  for
    select u.userid
    from bfw_sec_users u
    where u.isrole = 0
    into :userid 
  do begin
    select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
    into :state;

    if (state = 1) then suspend;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable userid  varchar(38);
begin
  userid = user;
  select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
  into :state;
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_LEN (
    STRG_IN VARCHAR(1024))
RETURNS (
    STRG_LEN INTEGER)
AS
    begin
      /*
        get string length
      */

      if (strg_in is null)
        then
          strg_len = null;
        else
          begin
            strg_len = 0;
            while (strg_in || '.'  <> '.')
              do
                begin
                  strg_in = substring( strg_in from 2);
                  strg_len = strg_len + 1;
                end
          end

      suspend;
    end^


CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_REPLACE (
    STR_IN VARCHAR(1024),
    STR_SEARCH VARCHAR(1024),
    STR_REPLACE VARCHAR(1024))
RETURNS (
    STR_OUT VARCHAR(1024))
AS
declare variable str_beg integer;
declare variable str_comp varchar(1024);
declare variable str_pre varchar(1024);
declare variable str_pst varchar(1024);
declare variable str_len_orig integer;
declare variable str_len_srch integer;
declare variable str_len_repl integer;
begin
  if ((str_in is null) or (str_search is null) or (str_replace is null)) then
  begin
    str_out = null;
    suspend;
    exit;
  end

  execute procedure bfw_utl_sp_string_len :str_in returning_values :str_len_orig;
   -- str_len_orig = strlen(str_in);

  execute procedure bfw_utl_sp_string_len :str_search returning_values :str_len_srch;
    --str_len_srch = strlen(str_search);

  execute procedure bfw_utl_sp_string_len :str_replace  returning_values :str_len_repl;
    --str_len_repl = strlen(str_replace);

  str_beg = 1;
  while (str_len_srch + str_beg - 1 <= str_len_orig) do
  begin
    execute procedure bfw_utl_sp_string_len :str_in returning_values :str_len_orig;
      --str_len_orig = strlen(str_in);


    execute procedure bfw_utl_sp_string_sub :str_in, :str_beg, str_len_srch returning_values :str_comp;

    if (str_comp || '.' = str_search || '.') then
    begin
      execute procedure bfw_utl_sp_string_sub :str_in, 1, :str_beg - 1
        returning_values :str_pre;

      execute procedure bfw_utl_sp_string_sub :str_in, :str_beg + :str_len_srch,
                  :str_len_orig - (:str_beg + :str_len_srch) + 1
                                                         returning_values :str_pst;

      str_in = coalesce(str_pre, '') || str_replace || coalesce(str_pst, '');

      str_beg = str_beg + str_len_repl - str_len_srch;

    end

    str_beg = str_beg + 1;
  end

  str_out = str_in;

  suspend;

end^


CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_SUB (
    STR_IN VARCHAR(1024),
    STR_BEG INTEGER,
    STR_LEN INTEGER)
RETURNS (
    STR_OUT VARCHAR(1024))
AS
declare variable str_chr char( 1);
declare variable str_cpy varchar( 1024);

begin
  /*
     get substring
     strg_beg : 1 ..
  */

  if ((str_in is null)
     or (str_beg is null)
     or (str_beg <= 0)
     or (str_len is null)
     or (str_len <= 0))
  then
    str_out = null;
  else
  begin
    str_cpy = str_in;
    while (1 < str_beg) do
    begin
      str_cpy = substring( str_cpy from 2);
      str_beg = str_beg - 1;
    end

    str_out = '';
    while (0 < str_len) do
    begin
      str_chr = substring( str_cpy from 1 for 1);
      if (str_chr || '.' <> '.') then
      begin
        str_out = str_out || str_chr;
        str_cpy = substring( str_cpy from 2);
        str_len = str_len - 1;
      end
      else
      begin
        str_len = 0;
      end
    end
  end

  suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE BFW_UI_STYLES
'OPTIONS:
color={red,yellow,green etc... + InfoBk};
font.style={bold,italic,underline,srikeout};
font.color={color}

Use static:
Set in ENT_FIELDS.OPTIONS "Style=<id style>" for content and
  "Style.Header=<id style>" for header

Use dynamics:
In select or strored procedure define fields
 UI_ROW_STYLE for row style or UI_<FIELD_NAME>_STYLE for field style
 and set id style

Sample define style:
ID = "style1"
OPTIONS = "Color=InfoBk;Font.Style=Bold"';

