/******************************************************************************/
/***         Generated by IBExpert 2011.08.15.2 10.12.2011 8:32:06          ***/
/******************************************************************************/

SET NAMES WIN1251;

CREATE DATABASE 'server:b52'
USER 'SYSDBA'
PAGE_SIZE 8192
DEFAULT CHARACTER SET WIN1251;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR BFW_INF_MSG_GEN;


/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION BFW_RAISE 'ERROR';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_CHECK (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    COMMON_EXISTS INTEGER,
    USER_EXISTS INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_GET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_SET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50),
    VALI_ INTEGER,
    VALS_ VARCHAR(250),
    VALN_ DOUBLE PRECISION,
    VALD_ DATE)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_POP (
    FROM_ID_ INTEGER)
RETURNS (
    ID INTEGER,
    SDAT DATE,
    SENDER VARCHAR(38),
    TOPIC VARCHAR(50),
    TXT VARCHAR(250))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_PUSH (
    RECEIVER_ VARCHAR(38),
    TOPIC_ VARCHAR(50),
    TXT_ VARCHAR(250))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING_ (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_PERM VARCHAR(50),
    INHERITBY_RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UI_EV_LIST
RETURNS (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    ENTITYNAME VARCHAR(50),
    VIEWNAME VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    MENUIDX INTEGER,
    USEPERM INTEGER,
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_LEN (
    STRG_IN VARCHAR(1024))
RETURNS (
    STRG_LEN SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_REPLACE (
    STR_IN VARCHAR(1024),
    STR_SEARCH VARCHAR(1024),
    STR_REPLACE VARCHAR(1024))
RETURNS (
    STR_OUT VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_SUB (
    STR_IN VARCHAR(1024),
    STR_BEG SMALLINT,
    STR_LEN SMALLINT)
RETURNS (
    STR_OUT VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE BFW_ENT (
    ENTITYNAME   VARCHAR(38) NOT NULL,
    SCHEMENAME   VARCHAR(38),
    IS_SCHEME    INTEGER DEFAULT 0 NOT NULL,
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE BFW_ENT_FIELDS (
    ENTITYNAME      VARCHAR(38) NOT NULL,
    VIEWNAME        VARCHAR(38) NOT NULL,
    FIELDNAME       VARCHAR(38) NOT NULL,
    BAND            VARCHAR(50),
    TITLE           VARCHAR(50),
    VISIBLE         INTEGER DEFAULT 1 NOT NULL,
    READONLY        INTEGER DEFAULT 0 NOT NULL,
    EDITOR          VARCHAR(50),
    EDITOR_OPTIONS  VARCHAR(1024),
    OPTIONS         VARCHAR(1024),
    REQ             INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE BFW_ENT_VIEW_LINKS (
    ENTITYNAME         VARCHAR(38) NOT NULL,
    VIEWNAME           VARCHAR(38) NOT NULL,
    LINKED_ENTITYNAME  VARCHAR(38) NOT NULL,
    LINKED_VIEWNAME    VARCHAR(38) NOT NULL,
    LINKED_FIELD       VARCHAR(38)
);


CREATE TABLE BFW_ENT_VIEWS (
    ENTITYNAME     VARCHAR(38) NOT NULL,
    VIEWNAME       VARCHAR(38) NOT NULL,
    SQL_SELECT     VARCHAR(1024),
    SQL_INSERT     VARCHAR(1024),
    SQL_UPDATE     VARCHAR(1024),
    SQL_DELETE     VARCHAR(1024),
    SQL_REFRESH    VARCHAR(1024),
    READONLY       INTEGER DEFAULT 1 NOT NULL,
    PKEY           VARCHAR(38),
    OPTIONS        VARCHAR(1024),
    IS_EXEC        INTEGER DEFAULT 0 NOT NULL,
    SQL_INSERTDEF  VARCHAR(1024)
);


CREATE TABLE BFW_INF_MSG (
    ID        INTEGER NOT NULL,
    STATUS    INTEGER DEFAULT 0 NOT NULL,
    SENDER    VARCHAR(38) DEFAULT USER NOT NULL,
    RECEIVER  VARCHAR(38) NOT NULL,
    TOPIC     VARCHAR(50) NOT NULL,
    TXT       VARCHAR(250) NOT NULL,
    IDAT      DATE DEFAULT 'NOW' NOT NULL,
    RDAT      DATE
);


CREATE TABLE BFW_INF_SETTINGS (
    NAME  VARCHAR(50) NOT NULL,
    USR   VARCHAR(50) NOT NULL,
    VALI  INTEGER,
    VALS  VARCHAR(250),
    VALN  DOUBLE PRECISION,
    VALD  DATE
);


CREATE TABLE BFW_INF_SETTINGS_META (
    NAME            VARCHAR(50) NOT NULL,
    TYP             INTEGER NOT NULL,
    TITLE           VARCHAR(50) NOT NULL,
    BAND            VARCHAR(50),
    IS_PREFERENCE   INTEGER DEFAULT 0 NOT NULL,
    EDITOR          VARCHAR(50),
    EDITOR_OPTIONS  VARCHAR(250),
    B52_NAME        VARCHAR(50),
    DEF_VALI        INTEGER,
    DEF_VALS        VARCHAR(250),
    DEF_VALN        DOUBLE PRECISION,
    DEF_VALD        DATE
);


CREATE TABLE BFW_SEC_ACL (
    PERMID  VARCHAR(38) NOT NULL,
    USERID  VARCHAR(38) NOT NULL,
    RESID   VARCHAR(38) NOT NULL,
    STATE   INTEGER NOT NULL
);


CREATE TABLE BFW_SEC_PERMISSIONS (
    PERMID       VARCHAR(38) NOT NULL,
    NAME         VARCHAR(50) NOT NULL,
    POLID        VARCHAR(38) NOT NULL,
    INHERITBY    VARCHAR(38),
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE BFW_SEC_POLICIES (
    POLID           VARCHAR(38) NOT NULL,
    NAME            VARCHAR(50) NOT NULL,
    PARENTID        VARCHAR(38),
    STATE           INTEGER NOT NULL,
    USE_RES         INTEGER NOT NULL,
    RES_PROVID      VARCHAR(38),
    RES_PARENT_SQL  VARCHAR(1024)
);


CREATE TABLE BFW_SEC_PROV (
    URI         VARCHAR(50) NOT NULL,
    ENTITYNAME  VARCHAR(50) NOT NULL
);


CREATE TABLE BFW_SEC_USER_ROLES (
    USERID  VARCHAR(38) NOT NULL,
    ROLEID  VARCHAR(38) NOT NULL
);


CREATE TABLE BFW_SEC_USERS (
    USERID  VARCHAR(38) NOT NULL,
    NAME    VARCHAR(50) NOT NULL,
    ISROLE  INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE BFW_UI (
    URI         VARCHAR(50) NOT NULL,
    CLS         VARCHAR(50) NOT NULL,
    ENTITYNAME  VARCHAR(50) NOT NULL,
    VIEWNAME    VARCHAR(50),
    TITLE       VARCHAR(50) NOT NULL,
    GRP         VARCHAR(50),
    MENUIDX     INTEGER DEFAULT 0 NOT NULL,
    OPTIONS     VARCHAR(1024),
    PARAMS      VARCHAR(1024),
    OUTS        VARCHAR(1024),
    USEPERM     INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE BFW_UI_CLS (
    CLS          VARCHAR(50) NOT NULL,
    VIEWNAME     VARCHAR(50) NOT NULL,
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE BFW_UI_CMD (
    URI           VARCHAR(50) NOT NULL,
    CMD           VARCHAR(50) NOT NULL,
    CAPTION       VARCHAR(50) NOT NULL,
    IDX           INTEGER DEFAULT 0 NOT NULL,
    GRP           VARCHAR(50),
    DEF           INTEGER DEFAULT 0 NOT NULL,
    HANDLER_KIND  INTEGER NOT NULL,
    HANDLER       VARCHAR(50),
    CMD_DATA      VARCHAR(1024),
    OPTIONS       VARCHAR(1024)
);


CREATE TABLE BFW_UI_GRP (
    GRP  VARCHAR(50) NOT NULL,
    IDX  INTEGER
);


CREATE TABLE BFW_UI_STYLES (
    ID       VARCHAR(50) NOT NULL,
    OPTIONS  VARCHAR(1024)
);




/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE BFW_ENT_VIEW_LINKS ADD CONSTRAINT UNQ1_BFW_ENT_VIEW_LINKS UNIQUE (ENTITYNAME, VIEWNAME, LINKED_ENTITYNAME, LINKED_VIEWNAME, LINKED_FIELD);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE BFW_ENT ADD CONSTRAINT PK_BFW_ENT PRIMARY KEY (ENTITYNAME);
ALTER TABLE BFW_ENT_FIELDS ADD CONSTRAINT PK_BFW_ENT_FIELDS PRIMARY KEY (ENTITYNAME, VIEWNAME, FIELDNAME);
ALTER TABLE BFW_ENT_VIEWS ADD CONSTRAINT PK_BFW_ENT_VIEWS PRIMARY KEY (ENTITYNAME, VIEWNAME);
ALTER TABLE BFW_INF_MSG ADD CONSTRAINT PK_BFW_INF_MSG PRIMARY KEY (ID);
ALTER TABLE BFW_INF_SETTINGS ADD CONSTRAINT PK_BFW_INF_SETTINGS PRIMARY KEY (NAME, USR);
ALTER TABLE BFW_INF_SETTINGS_META ADD CONSTRAINT PK_BFW_INF_SETTINGS_META PRIMARY KEY (NAME);
ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT PK_BFW_SEC_ACL PRIMARY KEY (PERMID, USERID, RESID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT PK_BFW_SEC_PERMISSIONS PRIMARY KEY (PERMID);
ALTER TABLE BFW_SEC_POLICIES ADD CONSTRAINT PK_BFW_SEC_POLICIES PRIMARY KEY (POLID);
ALTER TABLE BFW_SEC_PROV ADD CONSTRAINT PK_BFW_SEC_PROV PRIMARY KEY (URI);
ALTER TABLE BFW_SEC_USERS ADD CONSTRAINT PK_BFW_SEC_USERS PRIMARY KEY (USERID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT PK_BFW_SEC_USER_ROLES PRIMARY KEY (USERID, ROLEID);
ALTER TABLE BFW_UI ADD CONSTRAINT PK_BFW_UI PRIMARY KEY (URI);
ALTER TABLE BFW_UI_CLS ADD CONSTRAINT PK_BFW_UI_CLS PRIMARY KEY (CLS);
ALTER TABLE BFW_UI_CMD ADD CONSTRAINT PK_BFW_UI_CMD PRIMARY KEY (URI, CMD);
ALTER TABLE BFW_UI_GRP ADD CONSTRAINT PK_BFW_UI_GRP PRIMARY KEY (GRP);
ALTER TABLE BFW_UI_STYLES ADD CONSTRAINT PK_BFW_UI_STYLES PRIMARY KEY (ID);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX BFW_SEC_PERMISSIONS_IDX_POL ON BFW_SEC_PERMISSIONS (POLID);
CREATE INDEX SEC_BFW_POLICIES_IDX_PARENT ON BFW_SEC_POLICIES (PARENTID);


/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_CHECK (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    COMMON_EXISTS INTEGER,
    USER_EXISTS INTEGER)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));

  common_exists = 0; user_exists = 0;

  if (exists(select * from  bfw_inf_settings s
      where s.name = :name_ and s.usr = :username_)) then
    user_exists = 1;

  if (exists(select * from bfw_inf_settings s
      where s.name = :name_ and s.usr = '')) then
    common_exists = 1;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_GET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));
  select s.vali, s.vals, s.valn, s.vald
  from bfw_inf_settings s
  where s.name = :name_ and s.usr = :username_
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null and username_ <> '') then
    select s.vali, s.vals, s.valn, s.vald
    from bfw_inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from bfw_inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_INF_EV_SETTING_SET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50),
    VALI_ INTEGER,
    VALS_ VARCHAR(250),
    VALN_ DOUBLE PRECISION,
    VALD_ DATE)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));

  if (vali_ is null and vals_ is null and valn_ is null and vald_ is null) then
    delete from bfw_inf_settings s
    where s.name = :name_ and s.usr = :username_;
  else
  begin
    if (exists(select * from bfw_inf_settings s where s.name = :name_ and usr = :username_)) then
      update bfw_inf_settings s
      set s.vali = :vali_, s.vals = :vals_, s.valn = :valn_, s.vald = :vald_
      where s.name = :name_ and s.usr = :username_;
    else
      insert into bfw_inf_settings(name, usr, vali, vals, valn, vald)
      values(:name_, :username_, :vali_, :vals_, :valn_, :vald_);
  end
end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_POP (
    FROM_ID_ INTEGER)
RETURNS (
    ID INTEGER,
    SDAT DATE,
    SENDER VARCHAR(38),
    TOPIC VARCHAR(50),
    TXT VARCHAR(250))
AS
declare variable receiver varchar(38);
begin
  receiver = user;
  from_id_ = coalesce(from_id_, 0);

  for
    select m.id, m.idat, coalesce(u.name, m.sender),  m.topic, m.txt
    from bfw_inf_msg m
         left join bfw_sec_users u on (u.userid = m.sender)
    where m.receiver = :receiver and m.status = 0 and m.id > :from_id_
    order by m.id
    into :id, :sdat, :sender, :topic, :txt
  do
    suspend;

end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_MSG_PUSH (
    RECEIVER_ VARCHAR(38),
    TOPIC_ VARCHAR(50),
    TXT_ VARCHAR(250))
AS
declare variable id integer;
begin
  receiver_ = upper(receiver_);
  id = gen_id(bfw_inf_msg_gen, 1);
  insert into bfw_inf_msg(id, receiver, topic, txt)
  values(:id, :receiver_, :topic_, :txt_);

end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
declare variable setting_title varchar(50);
begin
  select vali, vals, valn, vald from bfw_inf_sp_setting_(:name_)
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
  begin
    select m.title from bfw_inf_settings_meta m where m.name = :name_
    into :setting_title;

    setting_title = coalesce(setting_title, name_);

    exception bfw_raise 'Value for ''' || :setting_title || ''' undefined';
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_INF_SP_SETTING_ (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);

  select s.vali, s.vals, s.valn, s.vald
  from  bfw_inf_settings s
  where s.name = :name_ and s.usr = USER
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.vali, s.vals, s.valn, s.vald
    from  bfw_inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from  bfw_inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_PERM VARCHAR(50),
    INHERITBY_RESID VARCHAR(38))
AS
declare variable permcheck varchar(38);
declare variable permid varchar(38);
declare variable resid varchar(38);
begin
  permid_ = nullif(permid_, '');
  for
    select userid, name
    from bfw_sec_users
    into :userid, :username
  do begin
    for
      select p.permid, p.name
      from bfw_sec_policies pl left join bfw_sec_permissions p  on (pl.polid = p.polid)
      where pl.polid = :polid_
            and ((:permid_ is null) or (:permid_ is not null and p.permid = :permid_))
      into :permcheck, :perm
    do begin
      state = null;
      inheritby_perm = null;
      inheritby_resid = null;
      permid = null;
      resid = null;
      select p.state, p.permid, p.resid
      from bfw_sec_ev_perm_effective_(:permcheck, :userid, :resid_) p
      into :state, :permid, :resid;
      if (state is not null) then
      begin
        if (permid <> permcheck) then
          select name from bfw_sec_permissions p
          where p.permid = :permid
          into :inheritby_perm;

        if (coalesce(resid, resid_) <> resid_) then
          inheritby_resid = resid;

        suspend;
      end
    end
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
declare variable inheritby varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');
  permid = permid_;
  resid = resid_;

  for
    select a.state
    from bfw_sec_acl a
    where a.resid = :resid_ and a.userid = :userid_ and a.permid = :permid_
    into :state
  do
    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end

  select p.inheritby, pol.res_parent_sql
  from bfw_sec_permissions p left join bfw_sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :inheritby, :res_parent_sql;

  if (inheritby is null and res_parent_sql is null) then
  begin
    exit;
  end

  parent_resid = '';
  if (coalesce(res_parent_sql, '') <> '') then
  begin
    res_parent_sql = upper(res_parent_sql);
    execute procedure bfw_utl_sp_string_replace(:res_parent_sql, ':RESID', :resid_)
    returning_values :res_parent_sql;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      inheritby = permid_;

  end

  if (inheritby is not null) then
  begin
    select state, permid, resid from bfw_sec_ev_perm_effective_(:inheritby, :userid_, :parent_resid)
    into :state, :permid, :resid;

    if (state in (1, 2)) then
      suspend;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(50))
AS
begin
  for
    select p.permid, p.name, p.description, pi.name
    from bfw_sec_permissions p
         left join bfw_sec_permissions pi on (p.inheritby = pi.permid)
    where p.polid = :polid
    into :permid, :name, :description, :inheritby
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');
  select state
  from bfw_sec_acl p
  where p.resid = :resid and p.userid = :userid and p.permid = :permid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');

  if (state = 0) then
    delete from bfw_sec_acl p
       where p.resid = :resid and p.userid = :userid and p.permid = :permid;
  else
  begin
    if (exists(select * from bfw_sec_acl p
              where p.resid = :resid
                    and p.userid = :userid and p.permid = :permid)) then
     update bfw_sec_acl p
     set p.state = :state
     where p.resid = :resid and p.userid = :userid and p.permid = :permid;
    else
      insert into bfw_sec_acl(resid, userid, permid, state)
      values (:resid, :userid, :permid, :state);
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
begin
  for
    select p.polid, p.name, p.res_provid
    from bfw_sec_policies p
    where p.parentid is null and coalesce(:parentid, '') = ''
    union all
    select p.polid, p.name, p.res_provid
    from bfw_sec_policies p
    where p.parentid = :parentid and coalesce(:parentid, '') <> ''
    into :polid, :name, :res_provid
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
begin
  delete from bfw_sec_acl a
  where a.permid in (select p.permid from bfw_sec_permissions p where p.polid = :polid_);
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  select state
  from bfw_sec_policies p where p.polid= :polid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
begin
  update bfw_sec_policies p
  set p.state = :state
  where p.polid = :polid;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable unrestricted_perm varchar(38) = 'builtin.unrestricted' ;
declare variable pol_state integer;
declare variable roleid varchar(38);
declare variable parent_permid varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');

  select a.state
  from bfw_sec_acl a
  where a.permid = :unrestricted_perm and a.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

  select first 1 a.state
  from bfw_sec_acl a
       left join bfw_sec_user_roles r on (a.userid = r.roleid)
  where a.permid = :unrestricted_perm and r.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

  select p.inheritby, pol.res_parent_sql, pol.state
  from bfw_sec_permissions p left join bfw_sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :parent_permid, :res_parent_sql, :pol_state;

  if (pol_state <> 1) then
  begin
    state = 1;
    suspend;
    exit;
  end

  for
    select a.state
    from bfw_sec_acl a
    where a.resid = :resid_ and a.userid = :userid_ and a.permid = :permid_
    into :state
  do
    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end

  for
    select r.roleid
    from bfw_sec_user_roles r
    where r.userid = :userid_
    into :roleid
  do begin
    select a.state
    from bfw_sec_acl a
    where a.resid = :resid_ and a.userid = :roleid and a.permid = :permid_
    into :state;

    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end
  end

  if (parent_permid is null and res_parent_sql is null) then
  begin
    state = 0;
    suspend;
    exit;
  end

  parent_resid = '';
  if (coalesce(res_parent_sql, '') <> '') then
  begin
    res_parent_sql = upper(res_parent_sql);
    execute procedure bfw_utl_sp_string_replace(:res_parent_sql, ':RESID', :resid_)
    returning_values :res_parent_sql;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      parent_permid = permid_;

  end

  if (parent_permid is not null) then
  begin
    select state from bfw_sec_sp_perm_check(:parent_permid, :userid_, :parent_resid)
    into :state;
    suspend;
    exit;
  end
  else
  begin
    state = 0;
    suspend;
    exit;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
declare variable userid  varchar(38);
declare variable pstate integer;
declare variable pname varchar(250);
begin
  userid = user;
  select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
  into :pstate;

  if (pstate <> 1) then
  begin
    select name from bfw_sec_permissions p where p.permid = :permid_
    into :pname;

    pname = coalesce(pname, permid_);

    pname = 'No permission for: ' || pname;
    exception bfw_raise :pname;

  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
declare variable state integer;
begin
  for
    select u.userid
    from bfw_sec_users u
    where u.isrole = 0
    into :userid 
  do begin
    select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
    into :state;

    if (state = 1) then suspend;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable userid  varchar(38);
begin
  userid = user;
  select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
  into :state;
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_UI_EV_LIST
RETURNS (
    URI VARCHAR(50),
    CLS VARCHAR(50),
    ENTITYNAME VARCHAR(50),
    VIEWNAME VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    MENUIDX INTEGER,
    USEPERM INTEGER,
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024))
AS
begin
  for
    select i.uri, i.cls, i.entityname, coalesce(i.viewname, c.viewname),
           i.title, i.grp, i.menuidx, i.useperm,
           i.options, i.params, i.outs
    from bfw_ui i
         left join bfw_ui_cls c on (i.cls = c.cls)
         left join bfw_ui_grp g on (g.grp = i.grp)
    order by g.idx, i.menuidx, i.title
    into :uri, :cls, :entityname, :viewname,
         :title, :grp, :menuidx, :useperm,
         :options, :params, :outs
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_LEN (
    STRG_IN VARCHAR(1024))
RETURNS (
    STRG_LEN SMALLINT)
AS
    begin
      /*
        get string length
      */

      if (strg_in is null)
        then
          strg_len = null;
        else
          begin
            strg_len = 0;
            while (strg_in || '.'  <> '.')
              do
                begin
                  strg_in = substring( strg_in from 2);
                  strg_len = strg_len + 1;
                end
          end

      suspend;
    end^


CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_REPLACE (
    STR_IN VARCHAR(1024),
    STR_SEARCH VARCHAR(1024),
    STR_REPLACE VARCHAR(1024))
RETURNS (
    STR_OUT VARCHAR(1024))
AS
declare variable str_beg integer;
declare variable str_comp varchar(1024);
declare variable str_pre varchar(1024);
declare variable str_pst varchar(1024);
declare variable str_len_orig smallint;
declare variable str_len_srch smallint;
declare variable str_len_repl smallint;
declare variable str_replaced varchar(1024);
begin
      /*
        replace substring
          str_beg : 1 ..

        examples:
          execute procedure lib_string_replace :strg_in, 1, 'to_replace', 'replacement'
                                               returning_values :strg_out, :strg_replaced;

          select my_table.my_text,
                   (select lib_string_replace.strg_out
                      from lib_string_replace( my_table.my_text, 1, 'MEMO:', 'Memo:'))
            from my_table;

          update my_table
            set my_table.my_text =
                  (select lib_string_replace.strg_out
                     from lib_string_replace( my_table.my_text, 1, 'MEMO:', 'Memo:'));
      */

  str_beg = 1;
  if ((str_in is null)
       or (str_beg is null)
       or (str_beg <= 0)
       or (str_search is null)
       or (str_replace is null)) then
  begin
    str_out = null;
    str_replaced = null;
  end
  else
  begin
    str_replaced = 0;
    execute procedure bfw_utl_sp_string_len :str_in returning_values :str_len_orig;
   -- str_len_orig = strlen(str_in);

    execute procedure bfw_utl_sp_string_len :str_search returning_values :str_len_srch;
    --str_len_srch = strlen(str_search);

    execute procedure bfw_utl_sp_string_len :str_replace  returning_values :str_len_repl;
    --str_len_repl = strlen(str_replace);

    while (str_len_srch + str_beg - 1 <= str_len_orig) do
    begin
      execute procedure bfw_utl_sp_string_len :str_in returning_values :str_len_orig;
      --str_len_orig = strlen(str_in);


      execute procedure bfw_utl_sp_string_sub :str_in, :str_beg, str_len_srch returning_values :str_comp;

      if (str_comp || '.' = str_search || '.') then
      begin
        execute procedure bfw_utl_sp_string_sub :str_in, 1, :str_beg - 1
          returning_values :str_pre;

        execute procedure bfw_utl_sp_string_sub :str_in, :str_beg + :str_len_srch,
                    :str_len_orig - (:str_beg + :str_len_srch) + 1
                                                         returning_values :str_pst;

        str_in = coalesce(str_pre, '') || str_replace || coalesce(str_pst, '');

        str_beg = str_beg + str_len_repl - str_len_srch;

        str_replaced = str_replaced + 1;
      end

      str_beg = str_beg + 1;
    end

    str_out = str_in;
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_UTL_SP_STRING_SUB (
    STR_IN VARCHAR(1024),
    STR_BEG SMALLINT,
    STR_LEN SMALLINT)
RETURNS (
    STR_OUT VARCHAR(1024))
AS
declare variable str_chr char( 1);
declare variable str_cpy varchar( 1024);

begin
  /*
     get substring
     strg_beg : 1 ..
  */

  if ((str_in is null)
     or (str_beg is null)
     or (str_beg <= 0)
     or (str_len is null)
     or (str_len <= 0))
  then
    str_out = null;
  else
  begin
    str_cpy = str_in;
    while (1 < str_beg) do
    begin
      str_cpy = substring( str_cpy from 2);
      str_beg = str_beg - 1;
    end

    str_out = '';
    while (0 < str_len) do
    begin
      str_chr = substring( str_cpy from 1 for 1);
      if (str_chr || '.' <> '.') then
      begin
        str_out = str_out || str_chr;
        str_cpy = substring( str_cpy from 2);
        str_len = str_len - 1;
      end
      else
      begin
        str_len = 0;
      end
    end
  end

  suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

UPDATE RDB$RELATIONS
SET RDB$DESCRIPTION = 'OPTIONS:
color={red,yellow,green etc... + InfoBk};
font.style={bold,italic,underline,srikeout};
font.color={color}

Use static:
Set in ENT_FIELDS.OPTIONS "Style=<id style>" for content and
  "Style.Header=<id style>" for header

Use dynamics:
In select or strored procedure define fields
 UI_ROW_STYLE for row style or UI_<FIELD_NAME>_STYLE for field style
 and set id style

Sample define style:
ID = "style1"
OPTIONS = "Color=InfoBk;Font.Style=Bold"'
WHERE (RDB$RELATION_NAME = 'BFW_UI_STYLES');

COMMIT WORK;

